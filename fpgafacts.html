---
layout: default
title: Technical Prep and Resume review
permalink: /technical-prep-review
nav_exclude: true
search_exclude: true
---

<h1>Technical Prep and Resume review</h1>

<h2>1) Homemade Networking Project Review</h2>
<ul>
  <li>Manchester encoding, colliding values will bring line low for too long - simply check for that. Idle is when everything goes high again (idle) re-attempt again - random retransmit with Linear Feedback shift registers (LFSR).</li>
  <li>LFSR - Q goes to D of flipflop then that q goes to next d etc…</li>
  <li>CRC8 construction generated from outputlogic site, still made testbenches for that, had to set initial value to another value though. (talk about that how this is the issue with codegen)</li>
  <li>Lil python script that would call on a .tcl file and run a vivado project creation with top_module set job #s top level, vhdl2008, “launch_simulation -simset sim_1”</li>
  <li>Use python with sys, and os to parse argos then run vivado in batch mode</li>
</ul>

<h2>2) Broadcast UDP</h2>
<ul>
  <li>Why UDP. SUPER BASIC LOL hard coded most with generics. Not that intelligent, good for just yelling into the void (no feedback).</li>
  <li>MII (media independent interface). Tx error, tx enable, tx clock, txd[3:0] same pins on rx side.</li>
  <li>Added a new clock in constraints, {0 20} that’s a 40ns period clock soooo 25mhz clk for mii.</li>
  <li>Problem encountered: wasn’t seeing any packets, ILAs seemed fine… Butttt it turns out that when your CRC is wrong the switch will drop it :)</li>
</ul>

<h2>3) Inference of Quantized Neural Networks</h2>
<ul>
  <li>Simple Neural networks with linear layers, (1,4) (4,16) (16,1)</li>
  <li>Quantize, so project into int16/8/4 territory. The maximum weight / bias maps to the maximum intn value.</li>
  <li>Uses DSP slices, built in MAC (multiply accumulate unit)</li>
  <li>DSP Blocks
    <ul>
      <li>27 x 18 signed multiply</li>
      <li>48-bit adder/accumulator</li>
      <li>27-bit pre-adder</li>
    </ul>
  </li>
  <li>Double check but I think it's called a DSP48E2</li>
</ul>

<h2>Trivia like questions</h2>
<ul>
  <li>3 ways to cross a clock domain : Async FIFO, Handshaking, Double flip flop</li>
  <li>Melee vs Moore: these are state machines. Melee depends on current state and the inputs, Moore just depends on current state.</li>
  <li>Inference: you “infer” the synthesis tool to place some type of component down.</li>
  <li>Instantiation: directly create the primitive component based on something like the user guide.</li>
  <li>Instantiation is better for explicitness but to infer components is better for cross platform.</li>
  <li>Flip flop will pass data from D to Q on the clock edge. A latch DOES NOT use a latch. in general Latches should be avoided (uncovered edge cases)</li>
  <li>A latch output will only change whenever an input change occurs, there is also sometimes an enable pin to reflect the changes from their input side.</li>
  <li>JTAG (Joint Test Action Group).</li>
  <li>Stack = Static stuff like int x = …. And the heap is dynamic like malloc and free.</li>
  <li>Likely question, why include a reset because on a turn on it could be an unpredictable state a reset gives you clarity and certification that after asserting the reset higher low. Depending on what you decide, it'll be an unknown State.</li>
  <li>Max value with bits, 2^8 = 256 possible values, max value is 2^8 - 1</li>
  <li>CLBs (Configurable logic blocks) fundamental building block of FPGAs, consist of logic cells which can be programmed for sequential / combinational logic. Usually contain a LUT for programming the behavior of any logic function and then has a FF for keeping a state.</li>
  <li>CDC (Clock Domain Crossing).</li>
  <li>Metastability = occurs when signal violates setup or hold time usually occurs when a signal is transferred between circuitry in unrelated or async clock domains.</li>
  <li>Metastability means a FF can settle to correct or incorrect value within an uncertain time.</li>
  <li>Setup time = data input muist arrive and stay steady for a duration of time before clock edge, changing too close to the edge the FF may grab the wrong value.</li>
  <li>Hold time = after clock edge the data must remain unchanged for brief period before moving on, FF could sample wrong value or go metasatable.</li>
  <li>Timing closure is making sure you meet setup and hold time.</li>
  <li>Slack in vivado: Positive slack means you’re meeting timing, zero slack means you’re barely meeting timing, negative slack means you have a timing violation.</li>
  <li>Slack = required time - arrival time, so slack is the margin between required arrival time and the actual arrival time of signal.</li>
  <li>LUT = Look up table, fundamental building block of an FPGA that implements combinational logic. It’s a small configurable memory unit that stores a truth table for a given logic function.</li>
  <li>Every python file is a module, when a file is imported as a module into another py script __name__ is set to the module’s filename instead. So set the __name__ == “__main__” to only run this code if this file is being executed directly, not when imported by another file.</li>
  <li>Python 3.10.4, 3.13.3</li>
  <li>with open("matmult_GEN.vhd", "w") as f:
    <ul>
      <li>Opens a file named matmult_GEN.vhd, w means write mode so if it exists then overwrite</li>
      <li>Open returns file object that you can write to and read from etc…</li>
    </ul>
  </li>
  <li>Multithreading - creating multiple threads in the smae process that will share the same memory space (RAM) and same variables & objs.</li>
  <li>In C fork() creates a new process. pthread_create() creates a new thread in C.</li>
  <li>Python features you like: string formatting is easy with print(f”hey {varname}”)</li>
  <li>I also really like the os and subprocess modules for quick system automation:
    <ul>
      <li>Import subprocess → subprocess.run([“pip”, “flag”, “stuff”])</li>
      <li>String interpolation is the print(f’hey {a}’)</li>
    </ul>
  </li>
  <li>Directed testing vs constrained-random testing. Directed testing is like looking for known behaviors using known testing. Stimulus constrained random testing is using random values maybe across like a bus but still using known values on like resets or enable pins.</li>
  <li>SystemVerilog Basics since you know VHDL more:
    <ul>
      <li>Non blocking <=</li>
      <li>Blocking =</li>
      <li>always_comb automatically executes once at time zero. It is sensitive to changes within the contents of a function.</li>
      <li>Always_ff @(posedge clk) begin … end. Represents a latch hence the sensitivity to a clock</li>
      <li>always_latch begin
        <ul>
          <li>if (enable) begin</li>
          <li>a_latch <= something;</li>
        </ul>
      </li>
      <li>//No else clause so a_latch's value</li>
      <li>//is not always defined, so it holds its value</li>
      <li>End</li>
      <li>Use assign for combinational logic. A type of wire or similar datatypes can be driven continuously with a value so constant or combinational.</li>
      <li>The SystemVerilog keywords are preferred, always_comb always_ff and always_latch.</li>
      <li>Statemachines in sv
        <ul>
          <li>typedef enum logic [1:0] {STT_DATA,</li>
          <li>STT_STOP,</li>
          <li>STT_WAIT</li>
          <li>} statetype;</li>
          <li>statetype state;</li>
          <li>case(state)</li>
          <li>STT_DATA: begin ….. End</li>
          <li>Default: begin … End</li>
          <li>End case</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>UVM Basics:
    <ul>
      <li>Agent contains the monitor, sequencer, driver</li>
      <li>Env contains the scoreboard and agent</li>
      <li>Test contains the env, interface, and DUT</li>
      <li>Interface connects to monitor, interface connects to driver</li>
      <li>Monitor connects to scoreboard</li>
      <li>Sequencer connects to driver.</li>
    </ul>
  </li>
</ul>
